<html>
    <head>
        <meta Content-Type:text/html; charset="UTF-8">
        <title>SnuInfoVis Term Project - GPS</title>
    </head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>

        let SVG_AREA_WIDTH = 500;
        let SVG_AREA_HEIGHT = 500;
        let AREA_MARGINS = {TOP:20, RIGHT:20, BOTTOM:30, LEFT:40};
        let AREA_WIDTH = SVG_AREA_WIDTH - AREA_MARGINS.LEFT - AREA_MARGINS.RIGHT;
        let AREA_HEIGHT = SVG_AREA_HEIGHT - AREA_MARGINS.TOP - AREA_MARGINS.BOTTOM;
        let GENRE_CATEGORY = ['k-pop', 'hiphop', 'classic', 'rock', 'r&b', 'jazz', 'country', 'pop']

        let mData; // load json
        let mMinYear = 1970; // fixed
        let mMaxYear = 0;

        let mSelectedYear = 2010;
        let mSelectedGenre = GENRE_CATEGORY[0];
        let mSelectedIndex = "danceability";
        let mSelectedPopularity = 72;

        d3.json("data.json").then(function(data) {
            mData = data;
            init();
        });

        function init() {
            console.log("mData size : " + mData.length);
            d3.select("h1").text("Hello!");

            // update year range from data.
            for (let i = 0 ; i < mData.length ; i++) {
                let year = mData[i].date.substring(0, 4);
                // mMinYear = Math.min(mMinYear, parseInt(year)); // mMinYear needs to be fixed.
                mMaxYear = Math.max(mMaxYear, parseInt(year));
            }

            drawAreaChart();
            drawVasePlot();
            drawLineChart();
            drawTable();
        }

        // -------------------- UTIL apis --------------------
        function translate(x, y) {
            return 'translate(' + x + ', ' + y + ')';
        }

        function getSongById(id) {
            for (let i = 0 ; i < mData.length ; i++) {
                if (id == mData[i].id) {
                    return mData[i];
                }
            }
        }

        function getSongsByYear(year) {
            let ret = [];
            for (let i = 0 ; i < mData.length ; i++) {
                if (mData[i].date.substring(0, 4) == year) {
                    ret.push(mData[i]);
                }
            }
            return ret;
        }

        function getColorByGenre(genre) {
            for (let i = 0 ; i < GENRE_CATEGORY.length ; i++) {
                if (genre == GENRE_CATEGORY[i]) {
                    //return d3.schemeCategory10[i];
                    return d3.schemeSet3[i];
                }
            }
        }

        // -------------------- DRAWING APIs --------------------
        function drawAreaChart() {

            let areaChartSvg = d3.select('#area');

            // axis
            let areaX = d3.scaleLinear().domain([mMinYear, mMaxYear + 1 /* +1 for 2020 data */ ])
                    .range([0, AREA_WIDTH]);

            let areaXAxis = d3.axisBottom(areaX).tickFormat(d3.format("d"));
            areaChartSvg.append("g").attr('transform', translate(AREA_MARGINS.LEFT,
                    AREA_HEIGHT + AREA_MARGINS.TOP)).call(areaXAxis);

            let areaY = d3.scaleLinear().domain([100, 0]).range([0, AREA_HEIGHT]);
            let areaYAxis = d3.axisLeft(areaY);
            areaChartSvg.append("g").attr('transform', translate(AREA_MARGINS.LEFT, AREA_MARGINS.TOP))
                    .call(areaYAxis);

            let xUnit = AREA_WIDTH / (mMaxYear - mMinYear + 1);
            let yUnit = AREA_HEIGHT / 100;
            let yBase = AREA_HEIGHT + AREA_MARGINS.TOP;

            // prepare prev values
            let prevSongs = getSongsByYear(mMinYear - 1);
            let prevData = {};

            // generate keys
            for (let i = 0 ; i < GENRE_CATEGORY.length ; i++) {
                prevData[ GENRE_CATEGORY[ i ] ] = 0;
            }

            // get counts per key(genre)
            for (let i = 0 ; i < prevSongs.length ; i++) {
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    if (prevSongs[i].genre == GENRE_CATEGORY[j]) {
                        prevData[ GENRE_CATEGORY[j] ]++;
                    }
                }
            }

            // normalize and calculate height values
            for (let i in prevData) {
                prevData[i] = ((prevData[i] / prevSongs.length) * 100) * yUnit;
            }

            for (let i = mMinYear ; i <= mMaxYear ; i++) {
                // prepare cur values
                let curSongs = getSongsByYear(i);
                let curData = {};

                // generate keys
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    curData[ GENRE_CATEGORY[j] ] = 0;
                }

                // get counts
                for (let j = 0 ; j < curSongs.length ; j++) {
                    for (let k = 0 ; k < GENRE_CATEGORY.length ; k++) {
                        if (curSongs[j].genre == GENRE_CATEGORY[k]) {
                            curData[ GENRE_CATEGORY[k] ]++;
                        }
                    }
                }

                // normalize and calculate height values
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    let counts = curData[ GENRE_CATEGORY[j] ];
                    curData[ GENRE_CATEGORY[j] ] = ((counts / curSongs.length) * 100) * yUnit;
                }

                let prevX = AREA_MARGINS.LEFT + 1/* for y axis line */ + (xUnit * (i - mMinYear));
                let curX = prevX + xUnit;
                let accPrevY = 0;
                let accCurY = 0;
                const areaTooltip = d3.select('body').append("div").style("position", "absolute")
                        .style("z-index", "10").style("visibility", "hidden");
                // line with fill from prev to cur
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    let curGenre = GENRE_CATEGORY[j];
                    let curColor = getColorByGenre(curGenre);
                    let dStr = 'M ' + prevX + ' ' + (yBase - accPrevY) +
                            ' V ' + (yBase - accPrevY - (prevData[ curGenre ])) +
                            ' L ' + curX + ' ' + (yBase - accCurY - (curData[ curGenre ])) +
                            ' V ' + (yBase - accCurY);
                    areaChartSvg.append('path').attr('class', curGenre).attr('fill', curColor)
                            .attr('id', i).attr('stroke', curColor).attr('d', dStr)
                            .on('mouseenter', function() {
                                d3.select(this).attr('fill', d3.rgb(curColor).darker(2));
                                return areaTooltip.style("visibility", "visible").text(i + ', ' + curGenre);
                            }).on('mousemove', function() {
                                return areaTooltip.style("top", (event.pageY - 10) + "px")
                                        .style("left", ( event.pageX + 10 ) + "px")
                                        .text(i + ', ' + curGenre);
                            }).on('mouseleave', function() {
                                d3.select(this).attr('fill', curColor);
                                return areaTooltip.style("visibility", "hidden");
                            }).on('click', function() {
                                console.log('mouse click(year : ' + i + ', genre : ' + curGenre + ')');
                                mSelectedYear = i;
                                mSelectedGenre = curGenre;
                                drawVasePlot();
                            });
                    accPrevY += prevData[ curGenre ];
                    accCurY += curData[ curGenre ];
                }
                prevSongs = curSongs;
                prevData = curData;
            }
        }

        function drawVasePlot() {
            d3.selectAll("rect").remove()
            d3.selectAll("line").remove()


            // prepare values
            let prevSongs = getSongsByYear(mSelectedYear);
            //prepare attributes
            let valence = []
            let energy = []
            let acousticness = []
            let danceability = []
            
            function getNormalized(array) {
                let min = Math.min(...array),
                    max = Math.max(...array);
                 return array.map(v => (v - min) / (max - min));
            }
            
            
            let temp = []


            for (let i = 0 ; i < prevSongs.length ; i++) {
                if (prevSongs[i].genre == mSelectedGenre) {
                    console.log(mSelectedGenre)
                    valence.push(prevSongs[i].valence)
                    energy.push(prevSongs[i].energy)
                    acousticness.push(prevSongs[i].acousticness)
                    danceability.push(prevSongs[i].danceability)
                    temp.push(prevSongs[i].tempo)
                    }
                }
            let tempo = getNormalized(temp)
           
           
            //console.log(valence)
            //console.log(energy)
            //console.log(acousticness)
            //console.log(danceability)
            //console.log((tempo))

            
            //valence
            let sorted_valence = valence.sort(d3.ascending)
            let v_q1 = d3.quantile(sorted_valence, .25)
            let v_median = d3.quantile(sorted_valence, .5)
            let v_q3 = d3.quantile(sorted_valence, .75)
            let v_interQuantileRange = v_q3 - v_q1
            let v_min = v_q1 - 1.5 * v_interQuantileRange
            let v_max = v_q1 + 1.5 * v_interQuantileRange

            //energy
            let sorted_energy = energy.sort(d3.ascending)
            let e_q1 = d3.quantile(sorted_energy, .25)
            let e_median = d3.quantile(sorted_energy, .5)
            let e_q3 = d3.quantile(sorted_energy, .75)
            let e_interQuantileRange = e_q3 - e_q1
            let e_min = e_q1 - 1.5 * e_interQuantileRange
            let e_max = e_q1 + 1.5 * e_interQuantileRange
    
            //acousticness
            let sorted_acousticness = acousticness.sort(d3.ascending)
            let a_q1 = d3.quantile(sorted_acousticness, .25)
            let a_median = d3.quantile(sorted_acousticness, .5)
            let a_q3 = d3.quantile(sorted_acousticness, .75)
            let a_interQuantileRange = a_q3 - a_q1
            let a_min = a_q1 - 1.5 * a_interQuantileRange
            let a_max = a_q1 + 1.5 * a_interQuantileRange

            //danceability
            let sorted_danceability = danceability.sort(d3.ascending)
            let d_q1 = d3.quantile(sorted_danceability, .25)
            let d_median = d3.quantile(sorted_danceability, .5)
            let d_q3 = d3.quantile(sorted_danceability, .75)
            let d_interQuantileRange = d_q3 - d_q1
            let d_min = d_q1 - 1.5 * d_interQuantileRange
            let d_max = d_q1 + 1.5 * d_interQuantileRange
                              
            //tempo
            let sorted_tempo = tempo.sort(d3.ascending)
            let t_q1 = d3.quantile(sorted_tempo, .25)
            let t_median = d3.quantile(sorted_tempo, .5)
            let t_q3 = d3.quantile(sorted_tempo, .75)
            let t_interQuantileRange = t_q3 - t_q1
            let t_min = t_q1 - 1.5 * t_interQuantileRange
            let t_max = t_q1 + 1.5 * t_interQuantileRange


            // set the dimensions and margins of the graph
            var margin = {top: 20, right: 20, bottom: 30, left: 40},
                 width = 500 - margin.left - margin.right,
                 height = 500 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            let svg = d3.select("#vase")
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform",
                           "translate(" + margin.left + "," + margin.top + ")");
            // Show the X scale
            let x = d3.scaleBand()
                    .range([ 0, width ])
                    .domain(["valence", "energy", "acousticness","danceability","tempo"])
                    .paddingInner(1)
                    .paddingOuter(.5)
                 svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))

            // Show the Y scale
            let y = d3.scaleLinear()
                    .domain([0,1])
                    .range([height, 0])
                 svg.append("g").call(d3.axisLeft(y))

        //valence  
            var v_center = 40
            var v_width = 50
            // Show the vertical line
            svg
            .append("line")
              .attr("x1", v_center)
              .attr("x2", v_center)
              .attr("y1", y(v_min) )
              .attr("y2", y(v_max) )
              .attr("stroke", "black")
            // Show the box
            svg
            .append("rect")
              .attr("x", v_center - v_width/2)
              .attr("y", y(v_q3) )
              .attr("height", (y(v_q1)-y(v_q3)) )
              .attr("width", v_width )
              .attr("stroke", "black")
              .style("fill", "#ff89da")
            // show median, min and max horizontal lines
            svg
            .selectAll("toto")
            .data([v_min, v_median, v_max])
            .enter()
            .append("line")
              .attr("x1", v_center-v_width/2)
              .attr("x2", v_center+v_width/2)
              .attr("y1", function(d){ return(y(d))} )
              .attr("y2", function(d){ return(y(d))} )
              .attr("stroke", "black")

        //energy  
        var e_center = 130
            var e_width = 50
            // Show the vertical line
            svg
            .append("line")
              .attr("x1", e_center)
              .attr("x2", e_center)
              .attr("y1", y(e_min) )
              .attr("y2", y(e_max) )
              .attr("stroke", "black")
            // Show the box
            svg
            .append("rect")
              .attr("x", e_center - e_width/2)
              .attr("y", y(e_q3) )
              .attr("height", (y(e_q1)-y(e_q3)) )
              .attr("width", e_width )
              .attr("stroke", "black")
              .style("fill", "#00d073")
            // show median, min and max horizontal lines
            svg
            .selectAll("toto")
            .data([e_min, e_median, e_max])
            .enter()
            .append("line")
              .attr("x1", e_center-e_width/2)
              .attr("x2", e_center+e_width/2)
              .attr("y1", function(d){ return(y(d))} )
              .attr("y2", function(d){ return(y(d))} )
              .attr("stroke", "black")

        //acousticness  
        var a_center = 220
        var a_width = 50
            // Show the vertical line
            svg
            .append("line")
              .attr("x1", a_center)
              .attr("x2", a_center)
              .attr("y1", y(a_min) )
              .attr("y2", y(a_max) )
              .attr("stroke", "black")
            // Show the box
            svg
            .append("rect")
              .attr("x", a_center - a_width/2)
              .attr("y", y(a_q3) )
              .attr("height", (y(a_q1)-y(a_q3)) )
              .attr("width", a_width )
              .attr("stroke", "black")
              .style("fill", "#ffe587")
            // show median, min and max horizontal lines
            svg
            .selectAll("toto")
            .data([a_min, a_median, a_max])
            .enter()
            .append("line")
              .attr("x1", a_center-a_width/2)
              .attr("x2", a_center+a_width/2)
              .attr("y1", function(d){ return(y(d))} )
              .attr("y2", function(d){ return(y(d))} )
              .attr("stroke", "black")

        //danceability  
        var d_center = 310
            var d_width = 50
            // Show the vertical line
            svg
            .append("line")
              .attr("x1", d_center)
              .attr("x2", d_center)
              .attr("y1", y(d_min) )
              .attr("y2", y(d_max) )
              .attr("stroke", "black")
            // Show the box
            svg
            .append("rect")
              .attr("x", d_center - d_width/2)
              .attr("y", y(d_q3) )
              .attr("height", (y(d_q1)-y(d_q3)) )
              .attr("width", d_width )
              .attr("stroke", "black")
              .style("fill", "#ff7972")
            // show median, min and max horizontal lines
            svg
            .selectAll("toto")
            .data([d_min, d_median, d_max])
            .enter()
            .append("line")
              .attr("x1", d_center-d_width/2)
              .attr("x2", d_center+d_width/2)
              .attr("y1", function(d){ return(y(d))} )
              .attr("y2", function(d){ return(y(d))} )
              .attr("stroke", "black")

        //tempo  
        var t_center = 400
            var t_width = 50
            // Show the vertical line
            svg
            .append("line")
              .attr("x1", t_center)
              .attr("x2", t_center)
              .attr("y1", y(t_min) )
              .attr("y2", y(t_max) )
              .attr("stroke", "black")
            // Show the box
            svg
            .append("rect")
              .attr("x", t_center - t_width/2)
              .attr("y", y(t_q3) )
              .attr("height", (y(t_q1)-y(t_q3)) )
              .attr("width", t_width )
              .attr("stroke", "black")
              .style("fill", "#4259ff")
            // show median, min and max horizontal lines
            svg
            .selectAll("toto")
            .data([t_min, t_median, t_max])
            .enter()
            .append("line")
              .attr("x1", t_center-t_width/2)
              .attr("x2", t_center+t_width/2)
              .attr("y1", function(d){ return(y(d))} )
              .attr("y2", function(d){ return(y(d))} )
              .attr("stroke", "black")
        }
            // TODO 조남우 draws or updates a chart considering mSelectedYear, mSelectedGenre.
            // TODO update mSelectedIndex as user selection.
            // TODO call drawLineChart().
        

        function drawLineChart() {
            // TODO 석상윤 draws or updates a chart considering mSelectedYear, mSelectedGenre, mSelectedIndex
            // TODO update mSelectedPopularity as user selection.
            // TODO call drawTable().
        }

        function drawTable() {
            // TODO 남재호 draws or updates a song table filtered by mSelectedYear, mSelectedGenre,
            //      mSelectedIndex, mSelectedPopularity
            // TODO show more info for a song when mouse on
            // TODO open selected song's spotify url.
        }

    </script>
    <body>
        <h1>Loading...</h1>
        <svg id="area" width=500 height=500 />
        <svg id="vase" width=500 height=500 />

    </body>
</html>
